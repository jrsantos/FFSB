/*
 *   Copyright (c) International Business Machines Corp., 2001-2004
 *
 *   This program is free software;  you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or 
 *   (at your option) any later version.
 * 
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY;  without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
 *   the GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program;  if not, write to the Free Software 
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */
#include <pthread.h>
#include <sys/time.h>
#include <sys/times.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#include <assert.h>

#include "config.h"

#include "ffsb.h"
#include "util.h"
#include "parser.h"

void     init_ffsb_config(ffsb_config_t *fc, unsigned num_fs, unsigned num_tg)
{
	
	memset(fc,0,sizeof(ffsb_config_t));
	
/* 	fc->verbose    = verbose; */
/* 	fc->directio   = directio; */
/* 	fc->bufferedio = bufferedio; */
	
	fc->num_totalthreads = -1;
	fc->num_threadgroups = num_tg;
	fc->num_filesys      = num_fs;
	
	fc->groups      = ffsb_malloc(sizeof(ffsb_tg_t)* num_tg);
	fc->filesystems = ffsb_malloc(sizeof(ffsb_fs_t)* num_fs);
}

void     init_ffsb_config_1fs(ffsb_config_t *fc,ffsb_fs_t *fs, ffsb_tg_t *tg)
{
	memset(fc,0,sizeof(*fc));
	
	fc->num_totalthreads = tg_get_numthreads(tg);
	fc->num_threadgroups = 1;
	fc->num_filesys      = 1;

	fc->groups      = tg;
	fc->filesystems = fs;
}

void    destroy_ffsb_config(ffsb_config_t *fc)
{
	int i;
	for ( i = 0 ; i < fc->num_filesys ; i++) {
		destroy_ffsb_fs(&fc->filesystems[i]);
	}
	for ( i = 0 ; i < fc->num_threadgroups ; i++) {
		destroy_ffsb_tg(&fc->groups[i]);
	}
	free(fc->groups);
	free(fc->filesystems);
}

void    fc_set_time(ffsb_config_t *fc, unsigned time)
{
	fc->time = time;
}

unsigned fc_get_num_filesys(ffsb_config_t *fc)
{
	return fc->num_filesys;
}

unsigned fc_get_num_threadgroups(ffsb_config_t *fc)
{
	return fc->num_threadgroups;
}

int      fc_get_num_totalthreads(ffsb_config_t *fc)
{
	return fc->num_totalthreads;
}

struct ffsb_tg * fc_get_tg(ffsb_config_t *fc, unsigned num)
{
	assert(num < fc->num_threadgroups );
	return &fc->groups[num];
}

struct ffsb_fs * fc_get_fs(ffsb_config_t *fc, unsigned num)
{
	assert(num < fc->num_filesys);
	return &fc->filesystems[num];
}

void     fc_set_num_totalthreads(ffsb_config_t *fc, int num)
{
	assert(num > 0);
	fc->num_totalthreads = num;
}

/* State information for the polling function below */
struct ffsb_time_poll {
	struct timeval starttime;
	int wait_time;
};


/* This is the polling function used by the threadgroups  to check elapsed */
/* time, when it returns 1 they know it is time to stop  */
static
int ffsb_poll_fn( void *ptr)
{
	struct ffsb_time_poll * data = (struct ffsb_time_poll *)ptr;  
	struct timeval curtime, difftime;
	gettimeofday(&curtime,NULL);
	
	timersub(&curtime, &data->starttime, &difftime);
	if( difftime.tv_sec >= data->wait_time) {
		return 1;
	}
	return 0;
}




int main(int argc, char *argv[])
{
	int i,j;
	ffsb_config_t fc;
	ffsb_barrier_t   thread_barrier, tg_barrier;
	tg_run_params_t *params;
	struct ffsb_time_poll pdata;
	struct timeval starttime, endtime, difftime;
	pthread_attr_t attr;
	ffsb_op_results_t results;
	double totaltime = 0.0f, usertime = 0.0f, systime = 0.0f;
	struct rusage before, after;
	pthread_t * fs_pts; /* threads to do filesystem creates in parallel */
	
	memset(&before,0,sizeof(before));
	memset(&after ,0,sizeof(after ));
	
	ffsb_unbuffer_stdout();

	if(argc < 2) {
		fprintf(stderr,"usage: %s <config file> [time]\n",
			argv[0]);
		exit(1);
	}

	/* VERSION comes from config.h (which is autogenerated by autoconf) */
	printf("FFSB version %s started\n\n",VERSION);

	if( argc == 3) {
		pdata.wait_time = atoi(argv[2]);
		printf("benchmark time set to %u sec\n",pdata.wait_time);
		ffsb_parse_oldconfig(&fc,argv[1]);
	} else {
		ffsb_parse_newconfig(&fc,argv[1]);
		pdata.wait_time = fc.time;
	}
	printf("benchmark time = %u\n",fc.time);

	pthread_attr_init(&attr);
	pthread_attr_setscope(&attr, PTHREAD_SCOPE_SYSTEM);


	params = ffsb_malloc( sizeof(tg_run_params_t) * fc.num_threadgroups);

	for(i = 0; i < fc.num_threadgroups ; i++ ) {
		tg_print_config( &fc.groups[i] );
	}
	
	fs_pts = ffsb_malloc(sizeof(pthread_t) * fc.num_filesys);

	gettimeofday(&starttime,NULL);
	for(i = 0; i < fc.num_filesys ; i++) {
		fs_print_config( &fc.filesystems[i] ); 		
		pthread_create(fs_pts + i,&attr, construct_ffsb_fs,&fc.filesystems[i]); 
	}
	fflush(stdout);
	for(i = 0; i < fc.num_filesys ; i++) {
		pthread_join(fs_pts[i],NULL);
	}

	gettimeofday(&endtime,NULL);
	timersub(&endtime,&starttime,&difftime);
	printf("fs setup took %ld secs\n",difftime.tv_sec);
	free(fs_pts);

	init_ffsb_op_results(&results);
	ffsb_barrier_init( &thread_barrier, fc.num_totalthreads);
	ffsb_barrier_init( &tg_barrier, fc.num_threadgroups + 1);
	

	ffsb_sync();
	
	for( i = 0 ; i < fc.num_threadgroups ; i++ ) {
		params[i].tg         = &fc.groups[i];
		params[i].fc         = &fc;
		params[i].poll_fn    = ffsb_poll_fn;
		params[i].poll_data  = &pdata;
		params[i].wait_time  = FFSB_TG_WAIT_TIME;
		params[i].tg_barrier = &tg_barrier;
		params[i].thread_barrier = &thread_barrier;

		pthread_create(&params[i].pt,&attr,tg_run, &params[i] );
	}

	
	ffsb_getrusage( &before); 
	gettimeofday( &pdata.starttime, NULL );
	
	ffsb_barrier_wait( &tg_barrier); /* sync with tg's to start*/
 	printf("Starting Actual Benchmark At: %s\n",ctime( &pdata.starttime.tv_sec));
	fflush(stdout);

	for( i = 0 ; i < fc.num_threadgroups; i++) {
		pthread_join( params[i].pt, NULL );
	}
	
	ffsb_sync();
	gettimeofday( &endtime, NULL );
	ffsb_getrusage( &after);
	
	printf("FFSB benchmark finished   at: %s\n", ctime(&endtime.tv_sec ));
	printf("Results:\n");
	fflush(stdout);

	for( i = 0 ; i < fc.num_threadgroups; i++) {
		tg_collect_results( &fc.groups[i], &results);
	}
	timersub(&endtime, &pdata.starttime, &difftime);

	totaltime = tvtodouble(&difftime);
	print_results(&results,totaltime);

	usertime = tvtodouble( &after.ru_utime ) - 
	    tvtodouble( &before.ru_utime );
	
	systime = tvtodouble( &after.ru_stime ) - 
	    tvtodouble( &before.ru_stime );
/* 	printf("%ld %ld %ld %ld %ld %ld %ld %ld\n", */
/* 	       after.ru_utime.tv_sec, */
/* 	       after.ru_utime.tv_usec, */
/* 	       before.ru_utime.tv_sec, */
/* 	       before.ru_utime.tv_usec, */
/* 	       after.ru_stime.tv_sec, */
/* 	       after.ru_stime.tv_usec, */
/* 	       before.ru_stime.tv_sec, */
/* 	       before.ru_stime.tv_usec); */
	       
	       
/* 	printf("%.1lf%% User   Time\n", 100 * usertime/totaltime); */
/* 	printf("%.1lf%% System Time\n", 100 * systime/totaltime); */
/* 	printf("%.1f%% CPU Utilization\n", 100*(usertime + systime) / totaltime); */
	free(params);
	destroy_ffsb_config(&fc);

	return 0;
}
