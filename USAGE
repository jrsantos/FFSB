NOTE:

This file only applies to the old pre-5.0 FFSB, see README for
up-todate information.

FFSB - General Introduction
---------------------------

The readblocksize is the size of each block read during each
read() transaction. If the readblocksize is the same as the readsize, 
than each read transaction involves a single read() system call.
This benchmark simulates an environment where (potentially) many threads
read from different files (with a random offset) in a file system. 

If the readblocksize is less than the readsize, than in each read() 
transaction, the benchmark repeatedly reads in blocks of readblocksize 
until the total readsize has been reached. The benchmark seeks forward 
readseeksize in between each block read. Setting the readseeksize to a 
value greater than 0 allows to examine the system's seek behavior, as the 
seek operation will break the read-ahead mechanism. Setting the seek size 
to 0 allows benchmarking sequential read operations.

Hence, the readsize is the total number of bytes read (in each read
transaction). If readblocksize is smaller than the readsize, the benchmark 
will split the read transaction into multiple requests to the read() system 
call. In each transaction, each read() call reads readblocksize bytes, and 
potentially seeks forward readseeksize bytes. This behavior repeats until 
the total readsize has been reached. 


Read and Write Behavior - Examples:
-----------------------------------

Assuming that the readsize and the readblocksize are the same, and
assuming that the number of transactions is set to 100, the benchmark will 
consist of 100 transactions where each read() transaction will read readsize 
from different files with a random offset.

Assuming the readsize is set to 400KB, the readblocksize is set to 4KB, the
seeksize is set to 0, plus the number of transactions is set to 100, This 
scenario will result into the benchmark reading from the same file 100 times 
(400KB/4KB) sequentially, and than to choose another file and do it all over 
again, until we hit the 100 transaction limit.
 
Assuming the readsize is set to 400KB, the readblocksize is set to 4KB, the
seeksize is set to 4KB, plus the number of transactions is set to 100, This 
scenario results into executing the read-seek operation 100 times on the same 
file. This is because the seeksize does not count against the 400KB that 
the benchmark has to read. Hence, at the end of the benchmark the read-write 
offset will be at 800KB, and not 400KB. The benchmark will execute
this scenario 100 times (transaction = 100) on different files.

The write benchmark is a bit different though (append to a file BM) .....
The goal of this benchmark is to analyze the efficiency of the I/O subsystem 
and not the cache per se. Hence, setting the writesize to 128KB & the number 
of transactions to 100, results into writing 100 * 128KB to different files 
in the file system. The ramification is that all the benchmarks available 
today do not take this behavior into consideration & only operate on a basis 
where the write to file behavior is 1:1 or n:n. The argument made is that real 
applications operate on basis where the write operations go from different 
threads to different files in the file system (a n:m ratio). If larger updates 
to a file are necessary, the benchmark allows specifying a large writesize.  

Please see the README file for more information & see the using.xyz files 
(different formats) for an explanation of all the parameters

Sequential Write Operations
---------------------------

To simulate sequential write opertions, do the following:

1) set the maxfilesize equal to the minfilesize
   -> this governes the maximum write size (the total write size per thread)
2) chose an appropriate write size (size per write operation)
   -> the maximum write size will be reached in these chunks   
3) specify a createweight (not a writeweight, as write means append in ffsb)
   -> simply set the flag to 1 and all the other opertion flags to 0
      to benchmark sequential write operations in a vacum
4) run ffsp


Direct I/O
----------

Direct I/O is now supported in a Linux environment. Please use the 
Makefile.dio to compile o Linux 2.4 and Linux 2.6. 
